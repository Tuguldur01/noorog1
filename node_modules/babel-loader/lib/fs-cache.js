<<<<<<< HEAD
"use strict";
=======
'use strict';
>>>>>>> 5a88520246291938171233a829a6c8d57a25619b

/**
 * Filesystem cache
 *
 * Given a file and a transform function, cache the result into files
 * or retrieve the previously cached files if the given file is already known.
 *
 * @see https://github.com/babel/babel-loader/issues/34
 * @see https://github.com/babel/babel-loader/pull/41
 */
<<<<<<< HEAD
var crypto = require("crypto");
var mkdirp = require("mkdirp");
var findCacheDir = require("find-cache-dir");
var fs = require("fs");
var os = require("os");
var path = require("path");
var zlib = require("zlib");
=======
var crypto = require('crypto');
var mkdirp = require('mkdirp');
var fs = require('fs');
var os = require('os');
var path = require('path');
var zlib = require('zlib');
>>>>>>> 5a88520246291938171233a829a6c8d57a25619b

/**
 * Read the contents from the compressed file.
 *
 * @async
 * @params {String} filename
 * @params {Function} callback
 */
<<<<<<< HEAD
var read = function read(filename, callback) {
  return fs.readFile(filename, function (err, data) {
    if (err) {
      return callback(err);
    }

    return zlib.gunzip(data, function (err, content) {
      var result = {};

      if (err) {
        return callback(err);
      }
=======
var read = function(filename, callback) {
  return fs.readFile(filename, function(err, data) {
    if (err) { return callback(err); }

    return zlib.gunzip(data, function(err, content) {
      var result = {};

      if (err) { return callback(err); }
>>>>>>> 5a88520246291938171233a829a6c8d57a25619b

      try {
        result = JSON.parse(content);
      } catch (e) {
        return callback(e);
      }

      return callback(null, result);
    });
  });
};

<<<<<<< HEAD
=======

>>>>>>> 5a88520246291938171233a829a6c8d57a25619b
/**
 * Write contents into a compressed file.
 *
 * @async
 * @params {String} filename
 * @params {String} result
 * @params {Function} callback
 */
<<<<<<< HEAD
var write = function write(filename, result, callback) {
  var content = JSON.stringify(result);

  return zlib.gzip(content, function (err, data) {
    if (err) {
      return callback(err);
    }
=======
var write = function(filename, result, callback) {
  var content = JSON.stringify(result);

  return zlib.gzip(content, function(err, data) {
    if (err) { return callback(err); }
>>>>>>> 5a88520246291938171233a829a6c8d57a25619b

    return fs.writeFile(filename, data, callback);
  });
};

<<<<<<< HEAD
=======

>>>>>>> 5a88520246291938171233a829a6c8d57a25619b
/**
 * Build the filename for the cached file
 *
 * @params {String} source  File source code
 * @params {Object} options Options used
 *
 * @return {String}
 */
<<<<<<< HEAD
var filename = function filename(source, identifier, options) {
  var hash = crypto.createHash("SHA1");
  var contents = JSON.stringify({
    source: source,
    options: options,
    identifier: identifier
=======
var filename = function(source, identifier, options) {
  var hash = crypto.createHash('SHA1');
  var contents = JSON.stringify({
    source: source,
    options: options,
    identifier: identifier,
>>>>>>> 5a88520246291938171233a829a6c8d57a25619b
  });

  hash.end(contents);

<<<<<<< HEAD
  return hash.read().toString("hex") + ".json.gz";
=======
  return hash.read().toString('hex') + '.json.gzip';
>>>>>>> 5a88520246291938171233a829a6c8d57a25619b
};

/**
 * Retrieve file from cache, or create a new one for future reads
 *
 * @async
 * @param  {Object}   params
 * @param  {String}   params.directory  Directory to store cached files
 * @param  {String}   params.identifier Unique identifier to bust cache
 * @param  {String}   params.source   Original contents of the file to be cached
 * @param  {Object}   params.options  Options to be given to the transform fn
 * @param  {Function} params.transform  Function that will transform the
 *                                      original file and whose result will be
 *                                      cached
 *
 * @param  {Function<err, result>} callback
 *
 * @example
 *
 *   cache({
 *     directory: '.tmp/cache',
 *     identifier: 'babel-loader-cachefile',
 *     source: *source code from file*,
 *     options: {
 *       experimental: true,
 *       runtime: true
 *     },
 *     transform: function(source, options) {
 *       var content = *do what you need with the source*
 *       return content;
 *     }
 *   }, function(err, result) {
 *
 *   });
 */
<<<<<<< HEAD
module.exports = function (params, callback) {
=======
var cache = module.exports = function(params, callback) {
>>>>>>> 5a88520246291938171233a829a6c8d57a25619b
  // Spread params into named variables
  // Forgive user whenever possible
  var source = params.source;
  var options = params.options || {};
  var transform = params.transform;
  var identifier = params.identifier;
<<<<<<< HEAD
  var directory = void 0;

  if (typeof params.directory === "string") {
    directory = params.directory;
  } else {
    directory = findCacheDir({ name: "babel-loader" }) || os.tmpdir();
  }

  var file = path.join(directory, filename(source, identifier, options));

  // Make sure the directory exists.
  return mkdirp(directory, function (err) {
    if (err) {
      return callback(err);
    }

    return read(file, function (err, content) {
      var result = {};
      // No errors mean that the file was previously cached
      // we just need to return it
      if (!err) {
        return callback(null, content);
      }
=======
  var directory = (typeof params.directory === 'string') ?
        params.directory :
        os.tmpdir();
  var file = path.join(directory, filename(source, identifier, options));

  // Make sure the directory exists.
  return mkdirp(directory, function(err) {
    if (err) { return callback(err); }

    return read(file, function(err, content) {
      var result = {};
      // No errors mean that the file was previously cached
      // we just need to return it
      if (!err) { return callback(null, content); }
>>>>>>> 5a88520246291938171233a829a6c8d57a25619b

      // Otherwise just transform the file
      // return it to the user asap and write it in cache
      try {
        result = transform(source, options);
      } catch (error) {
        return callback(error);
      }

<<<<<<< HEAD
      return write(file, result, function (err) {
=======
      return write(file, result, function(err) {
>>>>>>> 5a88520246291938171233a829a6c8d57a25619b
        return callback(err, result);
      });
    });
  });
<<<<<<< HEAD
};
=======
};
>>>>>>> 5a88520246291938171233a829a6c8d57a25619b
